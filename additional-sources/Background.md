The reason that codebases such as the Linux kernel are written in C is the high level of control these languages offer over the machine, allowing for highly performant code. Two principal aspects of C that aid in performance are the manual memory management and low runtime overhead. The traditional approach to ensure memory safety is to automate away memory management with a garbage collector; Lisp and Java are examples of garbage collected languages. Notwithstanding bugs in the implementation of the garbage collector, this guarantees memory safety, but results in more overhead, as the garbage collector must exist at runtime, causing performance degradation. This approach to memory management creates a false dichotomy between memory safety and performance. 

### Rust's Memory Safety Guarantee
Rust achieves memory safety without a garbage collector through the use of strict compile time rules: Lifetimes, Ownership, Borrowing, and Exclusive Mutability, all of which are checked at compile time [[runtime-rust.pdf]] [rust book](). Lifetimes simply denote how long a variable is valid in a program, which the rust compilerâ€™s borrow checker typically implicitly derives. For more complex lifetimes, the borrow checker will fail to automatically denote the lifetime and thus it must be done manually. This is a point of contention for new Rust programmers, as demonstrated through an analysis of stack overflow questions [[learning-challenges.pdf]]. Borrowing Ownership and Borrowing are two related ideas in Rust where each variable owns a value, which changes when another variable takes ownership, or the value is passed to a function. Borrowing is the passing of a reference to a variable or function, without changing ownership. Exclusive mutability is ensured through the compiler by enforcing that there is either one mutable reference or an arbitrary amount of immutable references [[learning-challenges.pdf]] [[memory-solved.pdf]]. There are also checks that are compiled into the machine code for each Rust program, which could be considered overhead. Performance wise, the most impactful of these is the bounds checker, which checks for out-of-bounds accesses \cite{zhang}. This suite of compile time checks guarantee memory safety so long as they are not deactivated using an unsafe block [[memory-solved.pdf]].

### [[Unsafe Rust]]
Talk about unsafe rust -- resulting in this graph:
![[safe-diagram.drawio.png]]

