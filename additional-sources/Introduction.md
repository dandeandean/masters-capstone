In the realm of systems development, C/C++ (henceforth referred to as C for brevity) are the typical choice when it comes to writing complex yet highly efficient systems. While this offers fast software with relatively expedient speed of development, it comes with one major cost: safety. More specifically, C can be written in such a way that allows for memory issues which in the best case could lead to slower software and in the worst case could lead to a bad actor hijacking the execution of the application. Some of these memory issues include buffer overflow attacks, dangling pointers, and memory leaks.

There have been many proposed solutions to these memory safety issues. But the simplest is re-implementing code bases written in C in a memory safe language. While this could be any memory safe language, Rust has recently gained popularity, evident in its appearance in the Linux kernel \cite{torvalds}. In early 2024 the United States Government released a report on the dire nature of software security as it relates to national cyber security goals. The report emphasizes the importance that programming languages play in the development of secure software. They offer the Rust programming language as a potential  solution to decades of dubious memory management caused by the C languages \cite{usa}. This may signify a push from the government to require that new applications must be written in Rust, or legacy C applications must be rewritten in Rust -- a simple solution, but a logistical nightmare.

While Rust offers high performance memory safety, many of the use-cases in which it is needed already have a C implementation. The transition from C to Rust poses a massive logistical problem. This problem is compounded by Rustâ€™s relatively steep learning curve, limiting access to talent that could feasibly implement these C programs in Rust. Furthermore attempts to fully automate this process have not yet proven fruitful.
